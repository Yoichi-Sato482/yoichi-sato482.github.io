<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GoLang教程</title>
    <url>/Go-Tutorial/</url>
    <content><![CDATA[<h1 id="go学习笔记"><a class="markdownIt-Anchor" href="#go学习笔记"></a> Go学习笔记</h1>
<h2 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h2>
<p>流程控制语句时用来控制程序中的各语句执行顺序的语句，可与其他语句组成一定功能的小逻辑模块</p>
<p>分为三大类：</p>
<ul>
<li>顺序结构</li>
<li>条件判断 <code>if</code></li>
<li>循环结构 <code>for</code></li>
</ul>
<h3 id="if-分支单分支"><a class="markdownIt-Anchor" href="#if-分支单分支"></a> <code>if</code> 分支（单分支）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ·[Conditions]·&#123;</span><br><span class="line">    ·[Codes]·    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>GoLang中可以不写条件表达式两边的括号</li>
<li><code>if</code>和表达式之间必须要有空格</li>
<li>GoLang必须要有大括号</li>
<li>赶回结果如果为False则直接跳过<code>&#123;Codes&#125;</code></li>
<li><code>if</code>中可以直接用 <code>name := Content;codes</code>定义变量</li>
</ul>
<h3 id="if分支双分支"><a class="markdownIt-Anchor" href="#if分支双分支"></a> <code>if</code>分支（双分支）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ·[Conditions]·&#123;</span><br><span class="line">    ·[Codes]·</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ·[Codes]·</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if分支多分支"><a class="markdownIt-Anchor" href="#if分支多分支"></a> <code>if</code>分支（多分支）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ·[Conditions]·&#123;</span><br><span class="line">    ·[Codes]·</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    ·[Codes]·</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    ·[Codes]·</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在多分支中已经执行了一个分支那么下面的分支则不会在进行判断执行</p>
<h3 id="switch分支"><a class="markdownIt-Anchor" href="#switch分支"></a> <code>Switch</code>分支</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ·[Conditions]·&#123;</span><br><span class="line"><span class="keyword">case</span> [value1],[value2],...:</span><br><span class="line">    Codes</span><br><span class="line"><span class="keyword">case</span> [value3],[value4],...:</span><br><span class="line">    Codes</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    Codes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> <code>for</code>循环</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> [index] ; [conditions(<span class="type">bool</span>)] ; [excution]&#123;</span><br><span class="line">    Codes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<ul>
<li>Switch后面接一个表达式（常量、变量、具有返回值的函数等都可以）</li>
<li>case后面如果是常量值则不能重复</li>
<li>switch后面各个值的数据类型必须匹配</li>
<li>case后面可以接多个值但需要用<code>,</code>分割</li>
<li>case后面不用携带break</li>
<li>可选择的default位置可以随意</li>
<li>switch也可以当作if分支使用</li>
<li>switch后面也可以直接声明/定义一个变量但是不推荐</li>
<li>switch穿透可以用<code>fallthrough</code>关键字，如果在case后面接一个<code>fallthrough</code>关键字则会执行下一个case也叫做switch穿透</li>
</ul>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<blockquote>
<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。</p>
</blockquote>
<h3 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组</h3>
<p>数组定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [name] [num]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>数组初始化</p>
<ul>
<li>使用初始值列表</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                </span><br><span class="line"><span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           </span><br><span class="line"><span class="comment">//使用指定的初始值完成初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>动态数组长度</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用索引值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;      </span><br></pre></td></tr></table></figure>
<p><strong>索引值从下标0开始</strong></p>
<ul>
<li>
<p>数组的遍历</p>
<p>基于<code>for</code>循环</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(nameArray);i++&#123;</span><br><span class="line">    fmt.Println(nameArray[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于<code>for range</code>遍历</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> nameArray&#123;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果将index换成_</span></span><br><span class="line"><span class="comment">//输出value则可以不要数组的索引</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h3>
<p>二维数组即数组中嵌套了另一个数组，二维数组的<code>[3][2]</code>代表的是：一共有三组数据，每一组的数据内含有2个数据<br />
定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">		&#123;<span class="string">&quot;0,0&quot;</span>, <span class="string">&quot;0,1&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;1,0&quot;</span>, <span class="string">&quot;1,1&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;2,0&quot;</span>, <span class="string">&quot;2,2&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对于二维数组的遍历可以使用forrange嵌套的方法输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">for</span> _, value1 := <span class="keyword">range</span> value &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s\t&quot;</span>, value2)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维数组只有外层可以使用<code>[...]</code>的写法，不支持内层的动态写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">        &#123;<span class="string">&quot;...&quot;</span>,<span class="string">&quot;...&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是二维数组是可以支持到动态写法的，只是在使用的时候不能用<code>[...]</code>的写法，如果要使用动态二维数组需要配合<code>make</code>进行数组初始化，如果不进行初始化也可以通过创建一维数组用<code>append()</code>加到二维数组之中。</p>
<ul>
<li>使用<code>make</code>对二维数组进行初始化
<blockquote>
<p><a href="https://blog.csdn.net/qq_37822034/article/details/107405871">参考代码</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">2</span></span><br><span class="line">	m := <span class="number">3</span></span><br><span class="line">	<span class="comment">//动态创建二维数组</span></span><br><span class="line">	grid := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		grid[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">			fmt.Print(grid[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:<br />
000<br />
000</p>
<ul>
<li>使用<code>append</code>对空的二维数组内容进行添加
<blockquote>
<p><a href="https://www.runoob.com/go/go-multi-dimensional-arrays.html">参考代码</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建空的二维数组</span></span><br><span class="line">    animals := [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三一维数组，各数组长度不同</span></span><br><span class="line">    row1 := []<span class="type">string</span>&#123;<span class="string">&quot;fish&quot;</span>, <span class="string">&quot;shark&quot;</span>, <span class="string">&quot;eel&quot;</span>&#125;</span><br><span class="line">    row2 := []<span class="type">string</span>&#123;<span class="string">&quot;bird&quot;</span>&#125;</span><br><span class="line">    row3 := []<span class="type">string</span>&#123;<span class="string">&quot;lizard&quot;</span>, <span class="string">&quot;salamander&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 append() 函数将一维数组添加到二维数组中</span></span><br><span class="line">    animals = <span class="built_in">append</span>(animals, row1)</span><br><span class="line">    animals = <span class="built_in">append</span>(animals, row2)</span><br><span class="line">    animals = <span class="built_in">append</span>(animals, row3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环输出</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> animals &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Row: %v\n&quot;</span>, i)</span><br><span class="line">        fmt.Println(animals[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> *多维数组</h3>
<p>多维数组可以暂时不进行了解，下面拿三维数组作为案例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m3 [<span class="number">3</span>][<span class="number">2</span>][<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    fmt.Println(m3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：<code>[[[0 0 0 0 0] [0 0 0 0 0]] [[0 0 0 0 0] [0 0 0 0 0]] [[0 0 0 0 0] [0 0 0 0 0]]]</code></p>
<blockquote>
<p>其实三维数组可以看作为多个二维数组的嵌套，这里的<code>[3][2][5]</code>代表的就是创建一个新的总长度为3的多维数组，每个数组里面嵌套有两个数组，嵌套的每个数组内有5个值</p>
</blockquote>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> [<span class="title">name</span>] <span class="params">(形参列表)</span></span> (返回值类型)&#123;</span><br><span class="line">    [Codes]</span><br><span class="line">    <span class="keyword">return</span> + 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要的返回值可以直接使用<code>_</code>忽略返回值</p>
<h3 id="函数内存分析"><a class="markdownIt-Anchor" href="#函数内存分析"></a> 函数内存分析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchangeNum</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">	temp = num1</span><br><span class="line">	num1 = num2</span><br><span class="line">	num2 = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num1, num2 <span class="type">int</span> = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;交换前: num1 = %d，num2 = %d\n&quot;</span>, num1, num2)</span><br><span class="line">	exchangeNum(num1, num2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;交换后: num1 = %d，num2 = %d\n&quot;</span>, num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上执行结果不变，函数未起作用</p>
<hr />
<p>原因如下：</p>
<p>当自定义函数执行完成后，<strong>Go会将函数存在的空间删除</strong>，以上程序仅在函数内进行数字交换但是<strong>并没有与<code>main</code>函数内的变量进行交换</strong><br />
因为函数的<code>基本数据类型</code>和<code>数组</code>默认都是<strong>值传递</strong>的，在函数内的<strong>任何修改都不会影响到原来的值</strong><br />
<img src="https://i.imgur.com/9qvpiYW.png" class="lazyload" data-srcset="https://i.imgur.com/9qvpiYW.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存分析" /><br />
解决方案：</p>
<p>可以将函数内的变量<strong>使用指针</strong>记录到内存地址里面，当在执行函数的时候程序会交换地址（内的数值）将输入的值进行交换，使用<code>&amp;num1,&amp;num2</code>来查看地址对应的值，这就是通过<strong>调取地址</strong>的方法在函数内用指针的方式操作变量，从效果看类似于引用传递</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-func exchangeNum(num1 int, num2 int) &#123;</span></span><br><span class="line"><span class="addition">+func exchangeNum(num1 *int, num2 *int) &#123;</span></span><br><span class="line">    var temp int</span><br><span class="line"><span class="deletion">-    temp = num1</span></span><br><span class="line"><span class="deletion">-    num1 = num2</span></span><br><span class="line"><span class="deletion">-    num2 = temp</span></span><br><span class="line"><span class="addition">+    temp = *num1</span></span><br><span class="line"><span class="addition">+    *num1 = *num2</span></span><br><span class="line"><span class="addition">+    *num2 = temp</span></span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var num1, num2 int = 10, 20</span><br><span class="line">	fmt.Printf(&quot;交换前: num1 = %d，num2 = %d\n&quot;, num1, num2)</span><br><span class="line"><span class="deletion">-	exchangeNum(num1, num2)</span></span><br><span class="line"><span class="addition">+       exchangeNum(&amp;num1, &amp;num2)</span></span><br><span class="line">	fmt.Printf(&quot;交换后: num1 = %d，num2 = %d\n&quot;, num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*    此处出现的diff语法为</span><br><span class="line">*    红色为源代码删除的部分</span><br><span class="line">*    绿色为修改后的部分</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/DzUoMcY.png" class="lazyload" data-srcset="https://i.imgur.com/DzUoMcY.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<h3 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h3>
<p>Go语言中不支持函数重载，即不能使用同一个函数在下方直接更改形参重新生成为新的函数，例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchangeNum</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">	temp = num1</span><br><span class="line">	num1 = num2</span><br><span class="line">	num2 = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchangeNum</span><span class="params">(num1 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">	temp = num1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要重载，则需要将函数的形参（参数）变为可变参数，在函数的<code>[name]</code>后面增加<code>...</code>就可以变成可变参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reFunc</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reFunc(<span class="number">0</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	reFunc(<span class="number">10</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	reFunc(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[0]</span><br><span class="line"></span><br><span class="line">[10]</span><br><span class="line"></span><br><span class="line">[10 20 30 40 50]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在处理<strong>可变参数</strong>时，Go语言会将<strong>可变参数</strong>看作为切片处理（可以看作为数组）<br />
可以使用遍历将<strong>可变参数</strong>内的数值遍历出来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reFunc</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		fmt.Println(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reFunc(<span class="number">0</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	reFunc(<span class="number">10</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	reFunc(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h2>
<blockquote>
<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性</p>
</blockquote>
<p>切片的本质实际上就是对底层数组的一个封装</p>
<p>声明切片类型的基本语法如下： <code>var name []T</code><br />
在构造切片的时候，索引范围为 <strong>左包含右不包含</strong></p>
<h3 id="获取切片"><a class="markdownIt-Anchor" href="#获取切片"></a> 获取切片</h3>
<h4 id="基于数组定义"><a class="markdownIt-Anchor" href="#基于数组定义"></a> 基于数组定义</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>&#125;</span><br><span class="line">	b := a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//从位置为 1 的数值开始取，取到第 4 歌数值</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;类型: %T\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<blockquote>
<p>[33 44 55 66 77]<br />
[44 55 66]<br />
类型: []int</p>
</blockquote>
<h4 id="通过make函数进行构造"><a class="markdownIt-Anchor" href="#通过make函数进行构造"></a> 通过<code>make</code>函数进行构造</h4>
<p>基本格式：<code>make([]T, size, cap)</code></p>
<ul>
<li><code>[]T</code> 为切片类型</li>
<li><code>size</code>为元素数量</li>
<li><code>cap</code> 为切片容量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, c)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片的长度和容量"><a class="markdownIt-Anchor" href="#切片的长度和容量"></a> 切片的长度和容量</h3>
<p>在GoLang中可以用内置的函数对切片的长度和容量进行获取</p>
<ul>
<li><code>len()</code> 函数获取切片长度</li>
<li><code>cap()</code> 函数获取切片容量</li>
</ul>
<p>对切片进行再次的切片操作的时，<strong>上限边界</strong> 是 <strong>切片容量 <code>cap()</code></strong> 而不是长度<code>len()</code>，所以常量索引必须是非负的并且在int类型的值限度内，对于其它类型的切片（如常量字符串）常量索引也必须在有效的范围内。</p>
<blockquote>
<p>如果low和high两个指标都是常数，它们必须满足low &lt;= high。如果索引在运行时超出范围，就会发生运行时panic。</p>
</blockquote>
<p>判断切片是否为空 <strong>只能使用<code>len(s) == 0</code></strong> 判断</p>
<h3 id="切片比较"><a class="markdownIt-Anchor" href="#切片比较"></a> 切片比较</h3>
<p>切片之间没有办法进行比较，所以也不可以用<code>==</code>判断两个切片内是否包含有相同的元素，唯一合法的操作是只能与<code>nil</code>进行比较</p>
<blockquote>
<p>一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil</p>
</blockquote>
<p>如下实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure>
<h3 id="切片的赋值"><a class="markdownIt-Anchor" href="#切片的赋值"></a> 切片的赋值</h3>
<p>如果要对切片进行赋值操作可以直接使用下标对切片对应的下标进行一个赋值操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="切片的赋值拷贝"><a class="markdownIt-Anchor" href="#切片的赋值拷贝"></a> 切片的赋值拷贝</h3>
<p>切片的复制可以通过以下的方法进行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d  %d\n&quot;</span>, a, b)</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d  %d\n&quot;</span>, a, b)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果:<br />
[0 0 0]  [0 0 0]<br />
[100 0 0]  [100 0 0]</p>
</blockquote>
<p>将变量b直接进行<code>b:= a</code>的赋值操作，这样b就与a共用一个内存地址，b发生变化a也相对应的发生变化。</p>
<h3 id="切片的遍历"><a class="markdownIt-Anchor" href="#切片的遍历"></a> 切片的遍历</h3>
<p>切片的底层为数组，所以切片一样可以用<code>for range</code>和索引遍历</p>
<h4 id="for-range遍历"><a class="markdownIt-Anchor" href="#for-range遍历"></a> for range遍历</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="索引遍历"><a class="markdownIt-Anchor" href="#索引遍历"></a> 索引遍历</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		fmt.Println(i, a[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用append对切片进行元素添加"><a class="markdownIt-Anchor" href="#使用append对切片进行元素添加"></a> 使用<code>append()</code>对切片进行元素添加</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		a = <span class="built_in">append</span>(a, i+<span class="number">1</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d\t len:%d\t cap:%d\n&quot;</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果:<br />
[10 1]	 len:2	 cap:2<br />
[10 1 2]	 len:3	 cap:4<br />
[10 1 2 3]	 len:4	 cap:4<br />
[10 1 2 3 4]	 len:5	 cap:8<br />
[10 1 2 3 4 5]	 len:6	 cap:8<br />
[10 1 2 3 4 5 6]	 len:7	 cap:8<br />
[10 1 2 3 4 5 6 7]	 len:8	 cap:8<br />
[10 1 2 3 4 5 6 7 8]	 len:9	 cap:16<br />
[10 1 2 3 4 5 6 7 8 9]	 len:10	 cap:16<br />
[10 1 2 3 4 5 6 7 8 9 10]	 len:11	 cap:16</p>
</blockquote>
<p>当通过<code>append()</code>对切片进行动态元素添加时，<code>append()</code>切片会自动判断容量是否足够下次的元素添加，所以在输出容量时会发现切片的容量在不断地增加</p>
<h3 id="append一次添加多个元素"><a class="markdownIt-Anchor" href="#append一次添加多个元素"></a> <code>append()</code>一次添加多个元素</h3>
<p><code>append()</code>也支持一次添加多个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果：[10 9 8 7 6]</p>
</blockquote>
<p>同时，使用<code>append()</code>也可以将另一个切片添加到原有的切片内</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	b := []<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">434</span>&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a, b...)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果: [11 22 33 434]</p>
</blockquote>
<h3 id="切片扩容的策略"><a class="markdownIt-Anchor" href="#切片扩容的策略"></a> *切片扩容的策略</h3>
<blockquote>
<p>可以通过查看$GOROOT/src/runtime/slice.go源码，其中扩容相关代码如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">	newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">		newcap = doublecap</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">		<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">		<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">			newcap += newcap / <span class="number">4</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">		<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">		<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			newcap = <span class="built_in">cap</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的代码可以看出以下内容：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
<li>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。</li>
</ul>
</blockquote>
<h3 id="使用copy复制切片"><a class="markdownIt-Anchor" href="#使用copy复制切片"></a> 使用<code>copy()</code>复制切片</h3>
<p>基本语法: <code>copy(destSlice, srcSlice []T)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	c := b</span><br><span class="line">	<span class="built_in">copy</span>(b, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\t%d\n&quot;</span>, a, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\t%d\n&quot;</span>, b, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\t%d\n&quot;</span>, c, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果<br />
a: 0xc00000e450	[1 2 3 4 5]<br />
b: 0xc00000e480	[1 2 3 4 5]<br />
c: 0xc00000e480	[1 2 3 4 5]</p>
</blockquote>
<p>注意：使用<code>copy()</code>复制的切片是给新的切片单独申请一个新的地址，而用赋值<code>:=</code>则是两个切片公用一个相同的地址</p>
<h3 id="切片元素的删除"><a class="markdownIt-Anchor" href="#切片元素的删除"></a> 切片元素的删除</h3>
<p>在GoLang中并没有一个内置函数可以对函数进行删除，当需要删除操作的时候，可以使用<code>append()</code>进行</p>
<p>删除索引为<code>index</code>的元素操作方法为<br />
<code>a = append(a[0:index], a[index+1:]...</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从切片中删除元素</span></span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line">	<span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">	a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">	fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理如下：<br />
<img src="https://i.imgur.com/hdJwRtf.png" class="lazyload" data-srcset="https://i.imgur.com/hdJwRtf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<h3 id="go语言排序"><a class="markdownIt-Anchor" href="#go语言排序"></a> Go语言排序</h3>
<p>GoLang内置了排序的函数包<code>sort</code>所以并不需要自己手写排序方法对切片进行排序</p>
<p>GoLang中<code>sort.Sort</code>使用的是快速排序的方法但不敢保证稳定性，另一种为<code>sort.Stable</code>使用的是稳定排序相对于快速排序稳定</p>
<h4 id="正序排序"><a class="markdownIt-Anchor" href="#正序排序"></a> 正序排序</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SortBy []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a SortBy)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a SortBy)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a SortBy)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i] &lt; a[j] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>&#125;</span><br><span class="line">	sort.Sort(SortBy(a))</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逆序排序"><a class="markdownIt-Anchor" href="#逆序排序"></a> 逆序排序</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>&#125;</span><br><span class="line">	sort.Sort(sort.Reverse(sort.IntSlice(a)))</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符数组排序"><a class="markdownIt-Anchor" href="#字符数组排序"></a> 字符数组排序</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">-14</span>&#125;</span><br><span class="line">    sort.Ints(a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    </span><br><span class="line">    ss := []<span class="type">string</span>&#123;<span class="string">&quot;surface&quot;</span>, <span class="string">&quot;ipad&quot;</span>, <span class="string">&quot;mac pro&quot;</span>, <span class="string">&quot;mac air&quot;</span>, <span class="string">&quot;think pad&quot;</span>, <span class="string">&quot;idea pad&quot;</span>&#125;</span><br><span class="line">    sort.Strings(ss)</span><br><span class="line">    fmt.Println(ss)</span><br><span class="line">    sort.Sort(sort.Reverse(sort.StringSlice(ss)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;After reverse: %v\n&quot;</span>, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="稳定排序"><a class="markdownIt-Anchor" href="#稳定排序"></a> *稳定排序</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> personSlice []person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s personSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s personSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s personSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i].Age &lt; s[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := personSlice&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			Name: <span class="string">&quot;AAA&quot;</span>,</span><br><span class="line">			Age:  <span class="number">55</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Name: <span class="string">&quot;BBB&quot;</span>,</span><br><span class="line">			Age:  <span class="number">22</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Name: <span class="string">&quot;CCC&quot;</span>,</span><br><span class="line">			Age:  <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Name: <span class="string">&quot;DDD&quot;</span>,</span><br><span class="line">			Age:  <span class="number">22</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Name: <span class="string">&quot;EEE&quot;</span>,</span><br><span class="line">			Age:  <span class="number">11</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Stable(a)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2>
<p>Go语言中的指针与C语言指针不同如下</p>
<ul>
<li>默认值是null</li>
<li><code>*</code>定义指针类型，<code>&amp;</code>取地址</li>
<li>不支持指针运算不支持<code>-&gt;</code>运算直接用<code>.</code>访问目标</li>
</ul>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<p>指针就是地址，指针就是存储地址的变量。</p>
<p><code>*p</code>在使用时为取值运算符（间接引用）</p>
]]></content>
      <categories>
        <category>筆記</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
        <tag>教學</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提升你的OSU!Mania底力 [持續更新...]</title>
    <url>/HowToUpgradeYourOSUmaniaAbility/</url>
    <content><![CDATA[<div class="note warning"><p>警告！本文章僅從個人經驗角度出發，具體需要考慮到個人的地力水平和承受能力，請不要完全依賴文章所講的內容練習，僅供參考。如果有出現錯誤或者需要修改內容歡迎在評論區留言。</p></div>
<p><strong>同時，封面圖片僅供參考實際情況因人而異。</strong></p>
<h1 id="part0-適合閱讀文章的人群"><a class="markdownIt-Anchor" href="#part0-適合閱讀文章的人群"></a> Part.0 適合閱讀文章的人群</h1>
<ul>
<li>已經擁有一部分的音樂遊戲基礎，且擁有足夠的節奏感</li>
<li>有一定的英文基礎，認識 <s>28</s> 26個英文字母</li>
<li>有一个自己的OSU帐号</li>
</ul>
<h1 id="part1-一切的起源-键位"><a class="markdownIt-Anchor" href="#part1-一切的起源-键位"></a> Part.1 一切的起源 - 键位</h1>
<p>對於一名想要開始入坑 O!m 或是想要要從 STD 跨越到 O!m 的玩家來講，首先需要設置一個讓你感覺最舒服的鍵位，這裏以 4K 的官方默認鍵位講，並不是所有人都適合 <code>D F J K</code> 這類型的緊湊型案件排布。當然這一切都要在你嘗試幾次之後做出決定。</p>
<p>不推薦在熟悉默認鍵位之後修改鍵位，當熟悉鍵位之後突然之間的切換會讓你的地力降低，重新熟悉鍵位需要一段時間，這段時間足夠可以練習更多類型的圖。其次，由於默認鍵位太過於緊湊，再打高難度的曲子 <strong>有可能</strong> 會出現錯亂的情況。所以不是很推薦使用官方提供的默認鍵位和在熟悉設置的鍵位之後突然修改鍵位的情況。</p>
]]></content>
      <categories>
        <category>技術提升</category>
      </categories>
      <tags>
        <tag>OSU</tag>
        <tag>HowTo</tag>
      </tags>
  </entry>
  <entry>
    <title>Talk-Update</title>
    <url>/Talk-Update/</url>
    <content><![CDATA[<h1 id="寫這篇文章就是想要講"><a class="markdownIt-Anchor" href="#寫這篇文章就是想要講"></a> 寫這篇文章就是想要講</h1>
<h2 id="disqus已經完全拋棄了因爲某些我不知道的原因disqus被startpage的插件攔截"><a class="markdownIt-Anchor" href="#disqus已經完全拋棄了因爲某些我不知道的原因disqus被startpage的插件攔截"></a> Disqus已經完全拋棄了！因爲某些我不知道的原因Disqus被Startpage的插件攔截</h2>
<h2 id="所以我換成了更方便一點的gitalk之後可能連旁邊的那個也給換掉"><a class="markdownIt-Anchor" href="#所以我換成了更方便一點的gitalk之後可能連旁邊的那個也給換掉"></a> 所以我換成了更方便一點的Gitalk，之後可能連旁邊的那個也給換掉</h2>
<h2 id="主要是我懶得而且沒有錢再續一年的vps但是用到6月應該沒什麼問題"><a class="markdownIt-Anchor" href="#主要是我懶得而且沒有錢再續一年的vps但是用到6月應該沒什麼問題"></a> 主要是我懶得而且沒有錢再續一年的VPS但是用到6月應該沒什麼問題</h2>
<h1 id="啊還有哦"><a class="markdownIt-Anchor" href="#啊還有哦"></a> 啊…還有哦</h1>
<h2 id="封面是我-自己畫的-是不是很可愛快說可愛"><a class="markdownIt-Anchor" href="#封面是我-自己畫的-是不是很可愛快說可愛"></a> 封面是我 <em>自己畫的</em> 是不是很可愛！快說可愛！</h2>
<h6 id="好耶~又水了一篇文章w"><a class="markdownIt-Anchor" href="#好耶~又水了一篇文章w"></a> 好耶~又水了一篇文章w</h6>
]]></content>
      <categories>
        <category>小型更新</category>
      </categories>
      <tags>
        <tag>唬爛</tag>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>2022喵喵落落格的年終總結耶！</title>
    <url>/The-End-of-2022/</url>
    <content><![CDATA[<h1 id="要新年了"><a class="markdownIt-Anchor" href="#要新年了"></a> 要新年了</h1>
<p>首先嘛，新年祝一直支持訪問以及關注落落格的貓貓們新年都有很多很多貓娘喫~也能成功度過這次的肺炎病毒的襲擊成爲超級健康貓貓。</p>
<h1 id="落落格今年發生的事情"><a class="markdownIt-Anchor" href="#落落格今年發生的事情"></a> 落落格今年發生的事情</h1>
<p>落落格到明天就是成立3個月的時候了，這三個月裏面，咱經歷了很多事情包括修改主題、搭建評論系統這些，但落落格到目前來說還是有很多的地方可以進行修改，在不停的修改之間落落格的各項功能也會變得相對完整最後變成咱想象中的樣子。當然咱也通過折騰的這麼長時間積累了不少的東西，對咱所用的框架和評論系統之類的熟練程度也是有很大的提高喵。</p>
<h1 id="喵喵站長的變化"><a class="markdownIt-Anchor" href="#喵喵站長的變化"></a> 喵喵站長的變化</h1>
<p>喵喵站長從之前的什麼都不會甚至把很多個Blog搭建起來就放到一邊不管的情況到現在能夠一直更新落落格（雖然說…想起來就寫一下文章然後進入潛水狀態）也是一點點的小小變化吧。今年咱認識了很多的可愛喵喵也失去了幾個比較要好的喵喵…咱希望咱認識和熟悉的喵喵能夠一直好好的，不要隨意就放棄自己的喵生什麼的…會很不開心的…<br />
因爲馬斯克收購Twitter的關係，喵也開始更新自己的其他實例了（<strong>馬斯克該死</strong>）<br />
雖然在今年的結尾喵喵感染了肺炎病毒但還好沒有什麼很嚴重的QAQ</p>
<h1 id="新年計劃"><a class="markdownIt-Anchor" href="#新年計劃"></a> 新年計劃</h1>
<ul>
<li>優化落落格的各種方面</li>
<li>認識更多的喵喵醬</li>
<li>和更多的喵喵一起贴貼一起喵喵喵</li>
<li>喵喵喵喵喵喵喵喵</li>
</ul>
<p>最後祝喵喵們</p>
<p><font size=8 color=#E87A90>新年快樂，有更多喵娘喫！</font></p>
]]></content>
      <categories>
        <category>總結</category>
      </categories>
      <tags>
        <tag>唬爛</tag>
        <tag>計劃</tag>
        <tag>新年</tag>
        <tag>落落格下一年要做什麼</tag>
      </tags>
  </entry>
  <entry>
    <title>落落格的第一篇文章</title>
    <url>/TheFirstPosts/</url>
    <content><![CDATA[<h1 id="唬爛不知道多少次寫文了"><a class="markdownIt-Anchor" href="#唬爛不知道多少次寫文了"></a> 唬爛！不知道多少次寫文了</h1>
<p>好久沒有寫文了，記得上次寫文還是在昨天<br />
但是！<s>速度與激情9</s> 還是不知道些什麼…<br />
就是要耍廢！好耶~~</p>
<h2 id="測試"><a class="markdownIt-Anchor" href="#測試"></a> 測試</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;唬爛！耶！！！！&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="這裏面會有什麼內容"><a class="markdownIt-Anchor" href="#這裏面會有什麼內容"></a> 這裏面會有什麼內容</h2>
<ul>
<li>唬爛</li>
<li>教程</li>
<li>音遊</li>
<li>折騰日記</li>
<li>各種無聊</li>
<li>各種耍廢</li>
<li>各種記錄</li>
<li>還有很多平時在社交平臺上面不會更新的內容</li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>唬爛</tag>
        <tag>Hexo</tag>
        <tag>落落格文章</tag>
      </tags>
  </entry>
  <entry>
    <title>加密測試文章</title>
    <url>/encryptpost/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="386530f8ab3946488e0f5d65db539c28c17f1932b518c3ec3bb6a27b3e06fcdc">0260f6355ba0936d04ec4f22e627c52e77f18f08becbbc1a74578357d495596e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">ㄟㄟ, 在这里輸入密码喵(密碼是KoriKoriMoe!).</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>日常</tag>
        <tag>測試</tag>
      </tags>
  </entry>
  <entry>
    <title>落落格未來規劃</title>
    <url>/future-planning/</url>
    <content><![CDATA[<h2 id="其實談什麼未來規劃根本就沒有什麼規劃"><a class="markdownIt-Anchor" href="#其實談什麼未來規劃根本就沒有什麼規劃"></a> 其實談什麼未來規劃根本就沒有什麼規劃</h2>
<p>每次想到一個想法都會開始 <s>頭腦風暴</s> 到底這個文章適不適合發到落落格上面，會不會造成一些什麼不太好的或者說…會不會踩到一部分人的地雷…非常糾結…</p>
<h2 id="有時候是真的不想把一些不太好的東西po上來"><a class="markdownIt-Anchor" href="#有時候是真的不想把一些不太好的東西po上來"></a> 有時候是真的不想把一些不太好的東西po上來</h2>
<p>因爲落落格是託管在Github上面的，有爭議或者涉及建政的一些東西就不能po上來。再者本喵的文采真的沒有很好，都是寫一堆有的沒的很口語化的文章。</p>
<h2 id="但是落落格的意義不就是把自己想到的東西記錄下來嘛"><a class="markdownIt-Anchor" href="#但是落落格的意義不就是把自己想到的東西記錄下來嘛"></a> 但是落落格的意義不就是把自己想到的東西記錄下來嘛</h2>
<p>所以，以後想到什麼就寫什麼好了…<br />
日常文章和唬爛文章會多一點</p>
]]></content>
      <tags>
        <tag>唬爛</tag>
        <tag>規劃</tag>
      </tags>
  </entry>
  <entry>
    <title>復活啦！！</title>
    <url>/newUpdate/</url>
    <content><![CDATA[<span class='p cyan center large'>恭喜我的blog復活!</span>
<p>額…然後是</p>
<span class='p red center large'>我的Blog友鏈需要大返修，不存在而且聯繫不上的友鏈將會被刪除</span>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Rimworld遊戲基礎不完全指北</title>
    <url>/rimworld-tutorial/</url>
    <content><![CDATA[<h1 id="rimworld-不完全基礎指北"><a class="markdownIt-Anchor" href="#rimworld-不完全基礎指北"></a> RimWorld 不完全基礎指北</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>首先，對於 <code>RimWorld</code> 網路上面有很多教程包括巴哈什麽的，本篇教程僅僅是自己根據游玩的經驗和藉鑒相關的教程總結出來的，所以，對剛接觸 <code>RimWorld</code> 的這款游戲的玩家比較友好。</p>
<p>也因爲 <code>RimWorld</code> 的自帶的翻譯令人一言難盡，對剛接觸游戲的玩家過了新手教程可能也不知道游戲的相關玩法，這篇文章能夠讓你理解這款游戲的基礎玩法。</p>
<p>(教程自帶目錄，不想看的地方可以直接跳過 XD)</p>
<h2 id="基礎内容"><a class="markdownIt-Anchor" href="#基礎内容"></a> 基礎内容</h2>
<p>RimWorld是一款類似廢土建造生存的2D沙盒游戲，總之經典模式就是自選3人，在這裏活下去並建立自己的殖民地（有點類似缺氧但是難度相比缺氧要友好一點）。</p>
<h2 id="基本玩法"><a class="markdownIt-Anchor" href="#基本玩法"></a> 基本玩法</h2>
<p>如果你看不懂 ENGLISH 建議先將語言修改爲 中文，游戲選單右下角就是修改語言的地方。<br />
<img src="/imgs/posts/Menu.png" class="lazyload" data-srcset="/imgs/posts/Menu.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" title="修改語言" alt="loading-ag-204" data-align="center"></p>
<h3 id="創建殖民地"><a class="markdownIt-Anchor" href="#創建殖民地"></a> 創建殖民地</h3>
<p>這裏不需要過多描述你也可以知道點擊哪個按鈕創建殖民地，當然也可以先看一遍游戲教學。</p>
<p>在創建殖民地的時候建議選擇 <code>墜落</code> 脚本，也可以自己創建專屬於自己的脚本進行游玩，教程以 <code>墜落</code> 脚本爲基礎。</p>
<p><font size=2 color=#0176D8>實際上Stream創意工坊的自定義脚本才好玩</font></p>
<p><img src="/imgs/posts/Choose.png" class="lazyload" data-srcset="/imgs/posts/Choose.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<p>對於 <code>AI故事敘述者</code> 更像是整個殖民地（游戲）的大難度，這裏直接截取Wikipedia上面的解釋。</p>
<blockquote>
<ul>
<li>
<p>“经典”卡桑德拉，借由逐渐增加负面事件，平顺地增加游戏的难度。</p>
</li>
<li>
<p>“友善”菲比，在每一个负面事件之间，有很长时间的和平，但是如果调高难度的话，仍然对玩家很有挑战性。</p>
</li>
<li>
<p>“随兴”兰迪，在随机间隔的游戏期间，提供无法预期的事件。负面事件发生的频率和规模是随机产生，并且可能发生在任何时间。</p>
</li>
</ul>
</blockquote>
<p><img src="/imgs/posts/Difficult.png" class="lazyload" data-srcset="/imgs/posts/Difficult.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<p>因爲是教程，所以以 <code>經典卡桑德拉 的 簡單 難度</code>（對於剛剛接觸這款游戲的也是推薦選擇這種難度），簡單難度會出現少量的襲擊事件，如果防禦措施做的合理，也不會出現很大的損失。但是下面的一定要選擇 <code>自由讀檔模式</code> ，無悔模式也就是極限模式，無法存檔無法讀檔。</p>
<h3 id="創建世界"><a class="markdownIt-Anchor" href="#創建世界"></a> 創建世界</h3>
<p><s>創建世界即創建世界</s></p>
<p>創建世界可以讓你選擇殖民地所在的位置，以及周圍的部落，但是就算是和平模式，如果你的殖民地距離周邊的部落距離太近，就算是中立的部落也會攻擊你的殖民地。</p>
<p>可以根據自己的需求來調整相關的參數</p>
<ul>
<li>
<p>種子：可以隨便填，會影響生成出的地形</p>
</li>
<li>
<p>生成比例：强烈建議生成比例選擇50%及以上，如果你的電腦性能比較强可以嘗試生成100%</p>
</li>
<li>
<p>整體降雨量：保持適中，過多和過少都會影響到游戲的可玩性</p>
</li>
<li>
<p>整體氣溫：保持適中，炎熱會導致過熱農作物無法生長，寒冷會導致殖民地需要隨時保持合適的溫度。</p>
</li>
<li>
<p>人口密度：不建議選擇稀少，選擇稀少會降低其他部落的商隊來到殖民地的次數</p>
</li>
<li>
<p>污染：根據自己的需求調整</p>
</li>
<li>
<p>派系：越豐富玩起來越有意思，但是也不建議完全沒有敵對部落</p>
</li>
</ul>
<img src="/imgs/posts/World.png" class="lazyload" data-srcset="/imgs/posts/World.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" title="" alt="" data-align="center">
<h3 id="降落點的選擇"><a class="markdownIt-Anchor" href="#降落點的選擇"></a> 降落點的選擇</h3>
<p>游戲整體的發展進度完全靠你所選擇的降落點。</p>
<img title="" src="/imgs/posts/Landed.png" class="lazyload" data-srcset="/imgs/posts/Landed.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-align="center">
<p>降落點的選擇推薦下面的屬性：</p>
<blockquote>
<p>溫帶森林</p>
<ul>
<li>
<p>地形：平原</p>
</li>
<li>
<p>移動難度：1</p>
</li>
<li>
<p>地質類型：花崗岩、大理岩、石灰岩爲主（不要選擇以板岩、砂岩爲主的地質）</p>
</li>
<li>
<p>平均溫度：全年0度以上，夏季最高溫度不要超過30度</p>
</li>
<li>
<p>植物生長季：全年</p>
</li>
<li>
<p>可覓食性：100%</p>
</li>
<li>
<p>動物放牧：是</p>
</li>
<li>
<p>Pollution（污染程度）：0</p>
</li>
<li>
<p>Nearby Pollution（附近污染程度）：越小越好最好為0.00</p>
</li>
<li>
<p>平均疾病頻率：越小越好</p>
</li>
<li>
<p>最好距離道路比較近</p>
</li>
</ul>
</blockquote>
<img title="" src="/imgs/posts/Place.png" class="lazyload" data-srcset="/imgs/posts/Place.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-align="center">
<h3 id="派系"><a class="markdownIt-Anchor" href="#派系"></a> 派系</h3>
<p>在降落點選擇的時候，可以點擊下面的 <code>派系</code> 按鈕來查看各個派系的主要人種和關係，要盡量避免附近有敵對派系。中立的派系可以在之後游戲中與商隊進行交易。</p>
<p><img src="/imgs/posts/Fuction.png" class="lazyload" data-srcset="/imgs/posts/Fuction.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<h3 id="理念"><a class="markdownIt-Anchor" href="#理念"></a> 理念</h3>
<p>如果沒有特別的玩法或者不想要涉獵理念和宗教系統可以選擇 <code>無理念系統</code> 或者 <code>經典理念</code></p>
<p>不同的理念系統會在游戲初期解鎖不同的内容</p>
<p><img src="/imgs/posts/Idea.png" class="lazyload" data-srcset="/imgs/posts/Idea.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<h3 id="創建角色"><a class="markdownIt-Anchor" href="#創建角色"></a> 創建角色</h3>
<p>創建角色決定了你在游戲中殖民地的發展速度和工作效率如何，最終選擇的三個角色團隊能力一定盡可能的達到平衡的狀態，并且所有角色不能有任何負面的能力（debuff）</p>
<p>下面的能力一定要刷掉：</p>
<blockquote>
<ul>
<li>
<p>懦弱</p>
</li>
<li>
<p>心理病態</p>
</li>
<li>
<p>嗜血狂怒</p>
</li>
<li>
<p>貪婪</p>
</li>
<li>
<p>食人族</p>
</li>
<li>
<p>縱火狂</p>
</li>
<li>
<p>迷戀藥物</p>
</li>
<li>
<p>嫉妒</p>
</li>
<li>
<p>貪吃</p>
</li>
<li>
<p>喜好藥物</p>
</li>
<li>
<p>纖纖弱質</p>
</li>
<li>
<p>仇男（女）</p>
</li>
<li>
<p>生性緊張</p>
</li>
<li>
<p>奇醜無比</p>
</li>
</ul>
</blockquote>
<p>無法執行的工作盡量不要有，有太多無法執行的工作會拖慢整體的發展速度。年齡不要在50及以上。</p>
<p>必須包含：擅長射擊（射擊等級高）、醫療、烹飪、種植等級6級以上，同時也要包含一個建造的興趣。</p>
<p>可以包含：格鬥、采礦、藝術、手工、高等級的社交，高等級的知識（加速研究）</p>
<h2 id="游戲正篇"><a class="markdownIt-Anchor" href="#游戲正篇"></a> 游戲正篇</h2>
<h3 id="進入地圖"><a class="markdownIt-Anchor" href="#進入地圖"></a> 進入地圖</h3>
<p>在正式進入游戲後，可以使用鍵盤的 <code>A S D W</code> 移動視角，滑鼠 <code>滾輪</code> 可以放大和縮小視角（<code>鍵盤的 PgUP和PgDown也可以實現</code>），<code>Space空白鍵</code> 可以暫停游戲時間，數字鍵 <code>1 2 3</code> 可以調整游戲進行的速度。</p>
<p>儅逃生艙降落以後，所選擇的人物出現后，可以按空白鍵暫停進行規劃。</p>
<h3 id="解禁物品"><a class="markdownIt-Anchor" href="#解禁物品"></a> 解禁物品</h3>
<p>在游戲中的 <code>建築</code> 選單内，選擇 <code>命令</code> 可以對殖民者發佈命令，選擇 <code>解除禁用</code> 將所有的打了紅色叉叉的物品全部框起來（按住左鍵)<img src="/imgs/posts/item.png" class="lazyload" data-srcset="/imgs/posts/item.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" />，執行完畢之後可以按滑鼠的右鍵取消當前選擇的命令，恢復普通選擇。</p>
<h3 id="裝備武器"><a class="markdownIt-Anchor" href="#裝備武器"></a> 裝備武器</h3>
<p>降落后一定要第一時間把携帶物資裏面的武器裝備上，槍支類武器對應射擊等級高的殖民者，點擊上方顯示的殖民者，右鍵武器可以進行裝備)，衣物也是相同的方法。<img src="/imgs/posts/Weapon.png" class="lazyload" data-srcset="/imgs/posts/Weapon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /> <img src="/imgs/posts/Defend.png" class="lazyload" data-srcset="/imgs/posts/Defend.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<h3 id="計劃區域"><a class="markdownIt-Anchor" href="#計劃區域"></a> 計劃區域</h3>
<p>區域規劃可以方便建造相關建築，使用 <code>建築</code> 選單，選擇 <code>命令</code> 内的 <code>計劃</code> )<img src="/imgs/posts/Plan.png" class="lazyload" data-srcset="/imgs/posts/Plan.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /> 選項，可以對殖民地進行計劃。</p>
<h4 id="種植區域"><a class="markdownIt-Anchor" href="#種植區域"></a> 種植區域</h4>
<p>種植區域一定要選擇在距離出生點 <strong>最近的沃土區域</strong> 并且範圍 <strong>至少要達到 200</strong> 在沃土上的作物生長速度最快</p>
<p><img src="/imgs/posts/Plants.png" class="lazyload" data-srcset="/imgs/posts/Plants.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" />    <img src="/imgs/posts/Dirt.png" class="lazyload" data-srcset="/imgs/posts/Dirt.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="沃土" title="沃土" /></p>
<p>可以按照下面的規劃方法進行簡單的規劃</p>
<img src="/imgs/posts/ExamplePlants.png" class="lazyload" data-srcset="/imgs/posts/ExamplePlants.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" title="" alt="" data-align="center">
<p>規劃完成之後，在 <code>區域</code> 選項選擇 <code>種植區</code> 左鍵拖出種植區域。</p>
<img src="/imgs/posts/Block-Plants.png" class="lazyload" data-srcset="/imgs/posts/Block-Plants.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" title="" alt="" data-align="center">
<h4 id="冷藏庫"><a class="markdownIt-Anchor" href="#冷藏庫"></a> 冷藏庫</h4>
<p>冷藏庫可以存儲打獵的動物尸體和收割後的農作物防止腐爛，冷庫在前10天可以選擇性的建設但不能不建設。冷庫建議建設在種植區附近，如果附近有間歇泉推薦向間歇泉方向發展。</p>
<p>如果冷藏庫建設在普通的平地上，建議設置雙層墻防止開門造成的溫度上升。</p>
<p><img src="/imgs/posts/ExampleFridge.png" class="lazyload" data-srcset="/imgs/posts/ExampleFridge.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<p>在冷藏庫規劃完成之後，需要進行區域的設置，在 <code>區域</code> 選項内選擇 <code>儲存區</code>，左鍵拖出區域設置儲存區。設置完成之後建議進行一下重新命名</p>
<div class="note warning"><p><strong>注意：冷藏庫和普通的倉庫一定要進行儲存類型的設置，不設置儲存類型則無法在冷藏庫存儲動物尸體和作物，可以參考下面表格進行設置，除了表格内的物品其他物品均為不允許</strong></p></div>
<div class="note info"><p>點擊設置的區域會在左下角出現區域的信息，儲存區會有儲存按鈕在左下角顯示的信息上方，點擊即可設置。</p></div>
<table>
<thead>
<tr>
<th>物品</th>
<th>子類</th>
</tr>
</thead>
<tbody>
<tr>
<td>尸體</td>
<td><img align=left src="https://img.icons8.com/fluency/16/null/checkmark.png" class="lazyload" data-srcset="https://img.icons8.com/fluency/16/null/checkmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /> 全部允許</td>
</tr>
<tr>
<td>自然資源</td>
<td><img align=left src="https://img.icons8.com/fluency/16/null/checkmark.png" class="lazyload" data-srcset="https://img.icons8.com/fluency/16/null/checkmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/> 植物原料</td>
</tr>
<tr>
<td>製造品</td>
<td><img align=left src="https://img.icons8.com/fluency/16/null/checkmark.png" class="lazyload" data-srcset="https://img.icons8.com/fluency/16/null/checkmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/> 藥品、藥物、麥汁</td>
</tr>
<tr>
<td>食物</td>
<td><img align=left src="https://img.icons8.com/fluency/16/null/checkmark.png" class="lazyload" data-srcset="https://img.icons8.com/fluency/16/null/checkmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/> 全部允許</td>
</tr>
<tr>
<td>允許大型實體</td>
<td><img align=left src="https://img.icons8.com/fluency/16/null/checkmark.png" class="lazyload" data-srcset="https://img.icons8.com/fluency/16/null/checkmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/> 允許</td>
</tr>
<tr>
<td>允許新鮮</td>
<td><img align=left src="https://img.icons8.com/fluency/16/null/checkmark.png" class="lazyload" data-srcset="https://img.icons8.com/fluency/16/null/checkmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/> 允許</td>
</tr>
</tbody>
</table>
<h4 id="倉庫"><a class="markdownIt-Anchor" href="#倉庫"></a> 倉庫</h4>
<p>倉庫位置可以隨意設置，但不建議設置在距離出生點太遠的地方。倉庫用來存儲不需要冷藏但放置在露天環境會老化的物品。</p>
<p><img src="/imgs/posts/ExampleStorage.png" class="lazyload" data-srcset="/imgs/posts/ExampleStorage.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /></p>
<div class="note info"><p>根據冷藏庫相反進行設置即可，設置方法與冷藏庫相同</p></div>
<h4 id="用餐區-工作區-娛樂區-厨房"><a class="markdownIt-Anchor" href="#用餐區-工作區-娛樂區-厨房"></a> 用餐區、工作區、娛樂區、厨房</h4>
<p>用餐區可以空間不需要很大，建議設置在厨房附近。</p>
<p>工作區主要放置研究桌、石材加工台等物品用於加工和研究。</p>
<p>娛樂區可以設置的相對大一點，如果同時有設置理念，可以將<code>儀式點、派對點、冥想點、結婚點設置在娛樂區内</code></p>
<p>厨房一定要設置 <code>爐灶、屠宰桌、屠宰點</code> 前期可以各設置一個。</p>
<img src="/imgs/posts/ExampleLife.png" class="lazyload" data-srcset="/imgs/posts/ExampleLife.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" title="" alt="" data-align="center">
<h4 id="住宅區"><a class="markdownIt-Anchor" href="#住宅區"></a> 住宅區</h4>
<p>住宅區可以利用剩餘的空間進行合理的分配，但是每個人的房間不能太小，最少需要6格的寬度才可以。</p>
<p><img src="/imgs/posts/ExampleALL.png" class="lazyload" data-srcset="/imgs/posts/ExampleALL.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" />  整體佈局可以參考，當然最終還是需要考慮到出生點地形進行修改，最合適的方案是這種集成式的方案，并且也是最方便的一種方案。</p>
<h2 id="合理規劃和生存下去"><a class="markdownIt-Anchor" href="#合理規劃和生存下去"></a> 合理規劃和生存下去</h2>
<p>在所有區域劃分完成之後，下面就要進行工作的分配。在游戲下方選擇 <code>工作</code> 即可進行安排，一定要開啓自定優先度。</p>
<div class="note info"><p>開啓自定優先度可以有更好的工作效率，參考下面的配置進行優先級設置</p></div>
<p><font color=#04b905>最高優先級（1級）：消防員、病患、醫生、療養、研究員</font></p>
<p><font color=#dbc56f>高優先級（2級）：厨師、獵人、建築工、農夫、采收者</font></p>
<p><font color=#b29c71>普通優先級（3級）：清潔、運送員、礦工、鍛造師、工匠</font></p>
<p><font color=#aaaaaa>低優先級（4級）：其他工作</font></p>
<h3 id="建造規劃"><a class="markdownIt-Anchor" href="#建造規劃"></a> 建造規劃</h3>
<p>前兩天一定要將住宅區建造好，同時進行封頂（規劃屋頂區），住宅區建造好之後是厨房和餐廳，餐廳可以直接建造3x3的木製大桌子，旁邊建造扶手椅。</p>
<p>每個房間都需要添加火把，在第4~5天可以開始建造冷藏庫和發電機，同時開始研究太陽能板和蓄電池。冷藏庫如果空間在200格需要2台空調，空調藍色的朝向冷藏庫裏面，紅色的朝向外面，前期推薦風力發電機和燃木發電機結合的方式提供電力，有了蓄電池和太陽能板之後可以將火把替換成立燈。</p>
<p>再建立一個垃圾區用來放置腐爛和變質的物品。</p>
<h3 id="種植"><a class="markdownIt-Anchor" href="#種植"></a> 種植</h3>
<p>生存下去最重要的是食物，所以在剛降落的前幾天一定要將種植區域全部種植作物，在種植完成之後需要儘快的將種植植物換成水稻，如果出現枯萎病一定要將所有人采收者的優先級調整爲1優先進行采收，過晚采收將會傳染到整片種植區域。</p>
<h3 id="研究"><a class="markdownIt-Anchor" href="#研究"></a> 研究</h3>
<p>研究首先要研究太陽能板和蓄電池，最好先研究蓄電池能夠存儲多餘的電力防止浪費。再進行微電子的研究，可以發展機槍塔（防禦）地熱能以及其他的娛樂設施，醫藥也是最重要的研究部分，剩餘的可以視情況進行相應的研究即可。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>RimWorld</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于咱为什么这么长时间没有更新</title>
    <url>/wy-longtime-nonupdate/</url>
    <content><![CDATA[<h1 id="更新内容"><a class="markdownIt-Anchor" href="#更新内容"></a> 更新内容</h1>
<p>先说一下咱消失的这段时间都更新了什么<br />
最大的更新就是将主题从头到尾全部更换了，也不在沉迷于魔改，平平淡淡才是真<br />
结尾有更详细的更新说明（咱承认是凑字数用的）</p>
<h1 id="消失跑路"><a class="markdownIt-Anchor" href="#消失跑路"></a> 消失！？跑路！？</h1>
<p>至于为什么消失是咱觉得，Hexo好难搞啊，好麻烦啊，但是去隔壁Hugo体验了一番虽然说配置和搭建更容易了但是…好像更难啊！！！<br />
所以才会消失这么长时间，消失的这段时间瓷砖都没有贴QAQ空了一大片（说好的今年努力把瓷砖贴满的）</p>
<p>之后几天应该会把咱在自学GoLang的笔记po上来，也算是和各路大佬交流一下什么的，有错误还可以让大佬指出来…</p>
<details ><summary> 你们不想看的更新日志（所以我隐藏了） </summary>
              <div class='content'>
              <div class="timeline"><p class='p h2'>2023更新日志</p><div class="timenode"><div class="meta"><p><p>2023-01 ver 1.5</p></p></div><div class="body"><ul><li>更换了主题</li><li>主页面元素增加</li><li>导航烂增加</li><li>顶栏增加</li><li>主题右键菜单修改</li></ul></div></div><div class="timenode"><div class="meta"><p><p>2023-03 ver 2.0</p></p></div><div class="body"><ul><li>修改了网站的背景图</li><li>增加了网站导航烂的描述</li><li>更换了主页面的个人资料图片</li><li>更新 <code>标签</code> 页面</li><li>更新 <code>分类</code> 页面</li><li>更新 <code>友链</code> 页面</li></ul></div></div></div>
              </div>
            </details>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>更新</tag>
      </tags>
  </entry>
</search>
